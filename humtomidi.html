<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hum to MIDI Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

        :root {
            --bg: #0a0a0a;
            --surface: #141414;
            --surface-highlight: #1f1f1f;
            --text-main: #ffffff;
            --text-muted: #888888;
            --accent: #ffffff;
            --border: #333333;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--surface-highlight);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* Custom Range Input Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--surface-highlight);
            border-radius: 2px;
        }

        /* Visualizer Canvas */
        #visualizer {
            width: 100%;
            height: 300px;
            /* border-bottom: 1px solid var(--border); */
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 70%);
        }
        
        /* Piano Roll Canvas */
        #piano-roll {
            width: 100%;
            height: 200px;
            background: #111;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }

        /* Animations */
        .pulse {
            animation: pulse-animation 2s infinite;
        }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.2); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background-color: #ff3b30;
            border-radius: 50%;
            display: inline-block;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            50% { opacity: 0.4; }
        }

        /* Glassy Panel */
        .panel {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border);
        }

        .btn-primary {
            background: var(--text-main);
            color: var(--bg);
            transition: all 0.2s ease;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255,255,255,0.2);
        }
        .btn-primary:disabled {
            background: #444;
            color: #888;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
        }

        .note-display {
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- Header & Visualizer Area -->
    <div class="flex-1 flex flex-col relative min-h-0">
        <header class="absolute top-0 w-full p-6 flex justify-between items-center z-10">
            <div class="flex items-center gap-3">
                <div class="w-6 h-6 border-2 border-white rounded-full flex items-center justify-center">
                    <div class="w-2 h-2 bg-white rounded-full"></div>
                </div>
                <h1 class="text-xl font-bold tracking-tight">HumToMidi</h1>
            </div>
            <div id="status-badge" class="text-xs font-mono text-gray-500 uppercase tracking-widest">
                Standby
            </div>
        </header>

        <!-- Main Visualization -->
        <div class="flex-1 flex flex-col items-center justify-center relative w-full">
            <canvas id="visualizer" class="absolute inset-0 w-full h-full opacity-80"></canvas>
            
            <!-- Current Note Display -->
            <div class="z-10 text-center pointer-events-none">
                <h2 id="note-name" class="text-8xl font-black text-white tracking-tighter mb-2 transition-all duration-100 scale-95 opacity-50">--</h2>
                <p id="frequency-display" class="text-gray-500 font-mono text-sm">0.00 Hz</p>
            </div>
        </div>

        <!-- Piano Roll Section (Hidden initially) -->
        <div id="piano-roll-container" class="hidden w-full px-6 pb-4 bg-[#0a0a0a] z-10">
             <div class="flex justify-between items-end mb-2">
                <h3 class="text-xs font-bold uppercase tracking-widest text-gray-400">Piano Roll Preview</h3>
                <button id="btn-playback" class="text-xs bg-white text-black px-3 py-1 rounded font-bold hover:bg-gray-200 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    Play Recording
                </button>
             </div>
             <canvas id="piano-roll"></canvas>
        </div>
    </div>

    <!-- Controls Area -->
    <div class="panel p-8 pb-10 w-full z-20">
        <div class="max-w-4xl mx-auto">
            
            <!-- Settings Row -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-8">
                <!-- Tempo -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Tempo</label>
                        <span id="bpm-val" class="text-xs font-mono font-bold text-white">120 BPM</span>
                    </div>
                    <input type="range" id="tempo-slider" min="40" max="200" value="120" step="1">
                </div>

                <!-- Metronome Volume -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Metronome Vol</label>
                        <span id="vol-val" class="text-xs font-mono font-bold text-white">70%</span>
                    </div>
                    <input type="range" id="volume-slider" min="0" max="100" value="70" step="1">
                </div>

                <!-- Mic Sensitivity -->
                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-xs font-bold uppercase tracking-widest text-gray-400">Mic Stability (Sens.)</label>
                        <span id="sens-val" class="text-xs font-mono font-bold text-white">Normal (7)</span>
                    </div>
                    <input type="range" id="sens-slider" min="1" max="100" value="50" step="1">
                </div>
            </div>

            <!-- Controls Row -->
            <div class="flex gap-4 items-center">
                <button id="toggle-metronome" class="w-14 h-14 rounded-xl border border-gray-600 flex flex-col items-center justify-center hover:border-white hover:bg-white hover:text-black transition-colors group">
                    <svg class="mb-1" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21l-6-18-6 18"/><path d="M21 21H9"/><circle cx="15" cy="18" r="3"/></svg>
                </button>

                <button id="btn-record" class="flex-1 py-4 rounded-xl bg-zinc-800 text-white font-semibold hover:bg-zinc-700 transition-colors flex items-center justify-center gap-2" disabled>
                    <span class="w-3 h-3 rounded-full bg-red-500"></span>
                    Start Recording
                </button>

                <button id="btn-stop" class="flex-1 py-4 rounded-xl border border-red-500/50 text-red-400 font-semibold hover:bg-red-500/10 transition-colors hidden flex items-center justify-center gap-2">
                    <span class="w-3 h-3 bg-current rounded-sm"></span>
                    Stop
                </button>

                <button id="btn-download" class="flex-1 py-4 rounded-xl btn-primary font-bold hidden flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    Download MIDI
                </button>
            </div>
        </div>
        
        <div id="mic-init-overlay" class="absolute inset-0 bg-black/90 backdrop-blur-md flex flex-col items-center justify-center z-50">
            <div class="p-8 border border-zinc-800 rounded-2xl bg-zinc-900/50 text-center max-w-md">
                <h2 class="text-2xl font-bold mb-2">HumToMidi</h2>
                <p class="text-gray-400 mb-6 text-sm">Initialize the audio engine to start humming.</p>
                <button id="btn-init" class="w-full px-8 py-4 bg-white text-black font-bold rounded-xl hover:scale-[1.02] transition-transform">
                    Initialize Microphone
                </button>
            </div>
        </div>
    </div>

    <script>
        /* --- Constants & State --- */
        const NOTE_STRINGS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const BUFFER_SIZE = 2048; 

        let audioContext = null;
        let analyser = null;
        let mediaStreamSource = null;
        let buffer = new Float32Array(BUFFER_SIZE);

        // Metronome State
        let isMetronomeOn = false;
        let bpm = 120;
        let metronomeVolume = 0.7;
        let nextNoteTime = 0.0;
        let timerID = null;
        let lookahead = 25.0;
        let scheduleAheadTime = 0.1;

        // Recording State
        let isRecording = false;
        let recordedEvents = []; // { midiNote, startTime (seconds), duration }
        let currentNote = null;
        let noteStartTime = 0;
        let sessionStartTime = 0;
        
        // Settings for Pitch Stability & Volume Gate
        let volumeGateThreshold = 0.03;       // RMS threshold (prevents recording silence)
        let pitchStabilityThreshold = 7;      // Samples needed to confirm a note change (Default for slider at 50)
        let pitchMatchCount = 0;              // Counter for consecutive matching notes
        let lastDetectedMidi = null;          // Used for stability check

        /* --- DOM Elements --- */
        const btnInit = document.getElementById('btn-init');
        const btnRecord = document.getElementById('btn-record');
        const btnStop = document.getElementById('btn-stop');
        const btnDownload = document.getElementById('btn-download');
        const btnMetronome = document.getElementById('toggle-metronome');
        const btnPlayback = document.getElementById('btn-playback');
        
        const tempoSlider = document.getElementById('tempo-slider');
        const bpmVal = document.getElementById('bpm-val');
        
        const volumeSlider = document.getElementById('volume-slider');
        const volVal = document.getElementById('vol-val');
        
        const sensSlider = document.getElementById('sens-slider');
        const sensVal = document.getElementById('sens-val');
        
        const noteDisplay = document.getElementById('note-name');
        const freqDisplay = document.getElementById('frequency-display');
        const statusBadge = document.getElementById('status-badge');
        
        const visualizerCanvas = document.getElementById('visualizer');
        const ctx = visualizerCanvas.getContext('2d');
        
        const pianoRollContainer = document.getElementById('piano-roll-container');
        const pianoRollCanvas = document.getElementById('piano-roll');
        const pCtx = pianoRollCanvas.getContext('2d');

        // Initial setup for default slider position
        sensVal.textContent = `Normal (${pitchStabilityThreshold})`;

        // Resize Canvas
        function resizeCanvas() {
            visualizerCanvas.width = window.innerWidth;
            visualizerCanvas.height = window.innerHeight * 0.6;
            
            // Piano roll width matches container
            if(pianoRollContainer.offsetParent !== null) {
                pianoRollCanvas.width = pianoRollContainer.clientWidth;
                pianoRollCanvas.height = 200;
                drawPianoRoll(); // Redraw if visible
            }
        }
        window.addEventListener('resize', resizeCanvas);

        /* --- Audio Engine Initialization --- */
        btnInit.addEventListener('click', async () => {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                // Smoothing for visualizer
                analyser.smoothingTimeConstant = 0.85;
                
                mediaStreamSource = audioContext.createMediaStreamSource(stream);
                mediaStreamSource.connect(analyser);
                
                document.getElementById('mic-init-overlay').style.display = 'none';
                btnRecord.disabled = false;
                
                statusBadge.textContent = "Ready";
                statusBadge.className = "text-xs font-mono text-green-500 uppercase tracking-widest";

                resizeCanvas();
                drawVisualizer();
                detectPitch();

            } catch (err) {
                console.error(err);
                // Use custom modal instead of alert()
                const errorMessage = "Microphone access denied. Please refresh and allow microphone access.";
                console.warn(errorMessage);
                // Simple placeholder for custom modal (since full modal UI is complex for this response)
                // In a real app, this would trigger a visible error message on the screen.
                noteDisplay.textContent = 'Error';
                freqDisplay.textContent = errorMessage;
            }
        });

        /* --- Pitch Detection (Autocorrelation) --- */
        function autoCorrelate(buf, sampleRate) {
            // 1. Compute RMS (Volume Gate)
            let rms = 0;
            for (let i = 0; i < buf.length; i++) {
                let val = buf[i];
                rms += val * val;
            }
            rms = Math.sqrt(rms / buf.length);
            
            // Volume Gate Check (prevents recording silence)
            if (rms < volumeGateThreshold) return -1; 

            // 2. Autocorrelation (rest of the logic unchanged)
            let r1 = 0, r2 = buf.length - 1, thres = 0.2;
            for (let i = 0; i < buf.length / 2; i++) {
                if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            }
            for (let i = 1; i < buf.length / 2; i++) {
                if (Math.abs(buf[buf.length - i]) < thres) { r2 = buf.length - i; break; }
            }

            buf = buf.slice(r1, r2);
            let c = new Array(buf.length).fill(0);
            for (let i = 0; i < buf.length; i++) {
                for (let j = 0; j < buf.length - i; j++) {
                    c[i] = c[i] + buf[j] * buf[j + i];
                }
            }

            let d = 0;
            while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < buf.length; i++) {
                if (c[i] > maxval) {
                    maxval = c[i];
                    maxpos = i;
                }
            }
            let T0 = maxpos;

            // Parabolic interpolation
            let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            let a = (x1 + x3 - 2 * x2) / 2;
            let b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);

            return sampleRate / T0;
        }

        function noteFromPitch(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            return Math.round(noteNum) + 69;
        }

        function detectPitch() {
            if (!analyser) {
                requestAnimationFrame(detectPitch); // Keep trying until initialized
                return;
            }

            analyser.getFloatTimeDomainData(buffer);
            const frequency = autoCorrelate(buffer, audioContext.sampleRate);

            if (frequency !== -1 && frequency > 60 && frequency < 2000) { // Filter extreme freqs
                const midiNum = noteFromPitch(frequency);
                const noteName = NOTE_STRINGS[midiNum % 12];
                const octave = Math.floor(midiNum / 12) - 1;
                
                noteDisplay.textContent = `${noteName}${octave}`;
                noteDisplay.style.opacity = "1";
                noteDisplay.style.transform = "scale(1.1)";
                freqDisplay.textContent = `${frequency.toFixed(1)} Hz`;

                handleNoteRecording(midiNum);
            } else {
                noteDisplay.style.opacity = "0.3";
                noteDisplay.style.transform = "scale(0.95)";
                handleNoteSilence();
            }

            requestAnimationFrame(detectPitch);
        }

        /* --- Recording Logic --- */
        function handleNoteRecording(midiNote) {
            if (!isRecording) return;
            const now = audioContext.currentTime;

            // 1. Check for stability (the "mic sensitivity" logic)
            if (midiNote === lastDetectedMidi) {
                pitchMatchCount++;
            } else {
                // Detected note changed, reset counter and store the new candidate
                pitchMatchCount = 1;
                lastDetectedMidi = midiNote;
            }

            // 2. Only proceed if the note is stable AND it's a new note
            if (midiNote !== currentNote && pitchMatchCount >= pitchStabilityThreshold) {
                
                // Close the previous note event if one was active
                if (currentNote !== null) {
                    recordedEvents.push({
                        note: currentNote,
                        start: noteStartTime - sessionStartTime,
                        duration: now - noteStartTime
                    });
                }

                // Start the new note event
                currentNote = midiNote;
                noteStartTime = now;
                // Reset counter after starting new note to immediately register duration
                pitchMatchCount = 0; 
            }
        }

        function handleNoteSilence() {
            if (!isRecording) return;
            const now = audioContext.currentTime;

            if (currentNote !== null) {
                // Silence detected while a note was active, close the note.
                recordedEvents.push({
                    note: currentNote,
                    start: noteStartTime - sessionStartTime,
                    duration: now - noteStartTime
                });
                currentNote = null;
                lastDetectedMidi = null; // Reset stability check
            }
            // If silence is detected, we also reset the match counter
            pitchMatchCount = 0;
        }

        /* --- Metronome Logic --- */
        function nextNote() {
            const secondsPerBeat = 60.0 / bpm;
            nextNoteTime += secondsPerBeat;
        }

        function playClickAt(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = 1000; 
            
            // FIX: Explicitly set and ramp the gain for a consistent click volume
            gain.gain.setValueAtTime(metronomeVolume, time); 
            gain.gain.linearRampToValueAtTime(0.001, time + 0.05); // Quick decay/release

            osc.start(time);
            osc.stop(time + 0.05);
        }

        function scheduler() {
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                playClickAt(nextNoteTime);
                nextNote();
            }
            timerID = setTimeout(scheduler, lookahead);
        }

        /* --- UI Interaction --- */
        tempoSlider.addEventListener('input', (e) => {
            bpm = e.target.value;
            bpmVal.textContent = `${bpm} BPM`;
        });

        volumeSlider.addEventListener('input', (e) => {
            metronomeVolume = e.target.value / 100;
            volVal.textContent = `${e.target.value}%`;
        });

        sensSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value, 10);
            // Map 1-100 (sensitivity) to stability threshold (15 down to 1)
            // High slider value (100) -> Low threshold (1) -> High sensitivity
            // Low slider value (1) -> High threshold (15) -> Low sensitivity (Stable)
            pitchStabilityThreshold = Math.max(1, Math.round(15 - (sliderValue / 100) * 14)); // Range 1 to 15
            
            let label = "Normal";
            if (sliderValue > 70) label = `High`;
            else if (sliderValue < 30) label = `Low`;
            
            sensVal.textContent = `${label} (${pitchStabilityThreshold})`;
        });

        btnMetronome.addEventListener('click', () => {
            isMetronomeOn = !isMetronomeOn;
            if (isMetronomeOn) {
                btnMetronome.classList.add('bg-white', 'text-black', 'border-white');
                if (audioContext?.state === 'suspended') audioContext.resume();
                nextNoteTime = audioContext.currentTime;
                scheduler();
            } else {
                btnMetronome.classList.remove('bg-white', 'text-black', 'border-white');
                clearTimeout(timerID);
            }
        });

        btnRecord.addEventListener('click', () => {
            isRecording = true;
            recordedEvents = [];
            currentNote = null; // Ensure fresh start
            lastDetectedMidi = null;
            pitchMatchCount = 0;
            sessionStartTime = audioContext.currentTime;
            
            btnRecord.classList.add('hidden');
            btnStop.classList.remove('hidden');
            btnDownload.classList.add('hidden');
            pianoRollContainer.classList.add('hidden');
            
            statusBadge.innerHTML = '<span class="recording-dot mr-2"></span>Recording';
            statusBadge.className = "text-xs font-mono text-white uppercase tracking-widest flex items-center";
        });

        btnStop.addEventListener('click', () => {
            isRecording = false;
            handleNoteSilence(); // Finalize any hanging note
            
            btnRecord.classList.remove('hidden');
            btnStop.classList.add('hidden');
            btnDownload.classList.remove('hidden');
            pianoRollContainer.classList.remove('hidden');
            
            statusBadge.textContent = "Session Ended";
            statusBadge.className = "text-xs font-mono text-blue-400 uppercase tracking-widest";

            resizeCanvas(); // Ensure piano roll size
            drawPianoRoll(); // Draw the notes
        });

        /* --- Piano Roll Visuals --- */
        function drawPianoRoll() {
            const w = pianoRollCanvas.width;
            const h = pianoRollCanvas.height;
            pCtx.clearRect(0, 0, w, h);
            
            if (recordedEvents.length === 0) {
                pCtx.fillStyle = "#333";
                pCtx.font = "12px Inter";
                pCtx.fillText("No notes recorded", 10, 20);
                return;
            }

            // Find bounds
            const finalEvent = recordedEvents[recordedEvents.length - 1];
            const totalTime = finalEvent.start + finalEvent.duration;
            
            // Map Pitch range (approx C2=36 to C6=84)
            const minPitch = 36;
            const maxPitch = 84;
            const pitchRange = maxPitch - minPitch;
            const noteHeight = h / pitchRange;

            // Draw Grid
            pCtx.strokeStyle = "#222";
            pCtx.lineWidth = 1;
            for(let i=0; i<pitchRange; i++) {
                pCtx.beginPath();
                pCtx.moveTo(0, i * noteHeight);
                pCtx.lineTo(w, i * noteHeight);
                pCtx.stroke();
            }

            // Draw Notes
            pCtx.fillStyle = "#ffffff";
            recordedEvents.forEach(evt => {
                // Clamp events to visible pitch range
                let noteVal = evt.note;
                if(noteVal < minPitch) noteVal = minPitch;
                if(noteVal > maxPitch) noteVal = maxPitch;

                const x = (evt.start / totalTime) * w;
                const width = Math.max((evt.duration / totalTime) * w, 2); // min width 2px
                // Higher pitch = lower Y value
                const y = h - ((noteVal - minPitch) * noteHeight) - noteHeight; 

                pCtx.fillRect(x, y, width, noteHeight - 1);
            });
        }

        /* --- Playback Logic --- */
        btnPlayback.addEventListener('click', () => {
            if(recordedEvents.length === 0) return;
            
            // Ensure audio context is running before playback
            if (audioContext?.state === 'suspended') audioContext.resume();

            const now = audioContext.currentTime;
            const masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);

            recordedEvents.forEach(evt => {
                const osc = audioContext.createOscillator();
                const env = audioContext.createGain();
                
                // Simple sine wave synth
                osc.type = 'sine'; 
                osc.frequency.value = 440 * Math.pow(2, (evt.note - 69) / 12);
                
                osc.connect(env);
                env.connect(masterGain);

                // Envelope to avoid clicking
                const start = now + evt.start;
                const end = start + evt.duration;
                
                osc.start(start);
                osc.stop(end);
                
                // Standard ADSR-like envelope (Attack 0.02s, Release 0.02s)
                env.gain.setValueAtTime(0, start);
                env.gain.linearRampToValueAtTime(1, start + 0.02); // Attack
                env.gain.setValueAtTime(1, end - 0.02); // Sustain until just before end
                env.gain.linearRampToValueAtTime(0, end); // Release
            });
        });

        /* --- Visualizer --- */
        function drawVisualizer() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const cx = visualizerCanvas.width / 2;
            const cy = visualizerCanvas.height / 2;
            const radius = Math.min(cx, cy) * 0.5;

            ctx.beginPath();
            
            // Only use lower ~35% of frequencies (human voice range) 
            // and map it to the full 360 degrees for visual reactivity
            const effectiveSlice = Math.floor(bufferLength * 0.35);
            
            for (let i = 0; i < effectiveSlice; i++) {
                const val = dataArray[i];
                const barHeight = val * 1.2; 
                
                // Map i from 0..effectiveSlice to 0..2PI angle
                const angle = (i / effectiveSlice) * Math.PI * 2;
                
                const x = cx + Math.cos(angle) * (radius + barHeight);
                const y = cy + Math.sin(angle) * (radius + barHeight);
                
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            // Close the loop smoothly
            const firstVal = dataArray[0] * 1.2;
            const firstX = cx + Math.cos(0) * (radius + firstVal);
            const firstY = cy + Math.sin(0) * (radius + firstVal);
            ctx.lineTo(firstX, firstY);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Simple inner circle
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.stroke();

            if(isRecording) {
                ctx.fillStyle = "rgba(255, 59, 48, 0.1)";
                ctx.fill();
            }

            requestAnimationFrame(drawVisualizer);
        }

        /* --- MIDI Generation --- */
        function numToBytes(num, bytes) {
            const arr = [];
            for (let i = bytes - 1; i >= 0; i--) {
                arr.push((num >> (8 * i)) & 0xFF);
            }
            return arr;
        }

        function varIntBytes(num) {
            let buffer = num & 0x7F;
            while ((num >>= 7)) {
                buffer <<= 8;
                buffer |= ((num & 0x7F) | 0x80);
            }
            const bytes = [];
            while (true) {
                bytes.push(buffer & 0xFF);
                if (buffer & 0x80) buffer >>= 8;
                else break;
            }
            return bytes;
        }

        btnDownload.addEventListener('click', () => {
            if (recordedEvents.length === 0) {
                console.warn("No notes recorded!");
                return;
            }
            // Filter out extremely short events (mic noise/clicks)
            const cleanEvents = recordedEvents.filter(e => e.duration > 0.05); 
            
            const HEADER_CHUNK = [0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x01, 0xE0];
            const TICKS_PER_BEAT = 480;
            const MICROSECONDS_PER_MINUTE = 60000000;
            const MPQN = MICROSECONDS_PER_MINUTE / bpm; 
            
            let midiEvents = [];
            cleanEvents.forEach(evt => {
                const startTick = Math.round(evt.start * (bpm / 60) * TICKS_PER_BEAT);
                const endTick = Math.round((evt.start + evt.duration) * (bpm / 60) * TICKS_PER_BEAT);
                midiEvents.push({ type: 'on', note: evt.note, time: startTick });
                midiEvents.push({ type: 'off', note: evt.note, time: endTick });
            });

            midiEvents.sort((a, b) => a.time - b.time);

            let trackData = [];
            let lastTime = 0;
            // Tempo Meta Event (0xFF 0x51 0x03)
            trackData.push(0x00, 0xFF, 0x51, 0x03, ...numToBytes(Math.round(MPQN), 3));

            midiEvents.forEach(evt => {
                const deltaTime = evt.time - lastTime;
                trackData.push(...varIntBytes(deltaTime)); 
                if (evt.type === 'on') trackData.push(0x90, evt.note, 0x40); // Note On, Channel 1, Velocity 64
                else trackData.push(0x80, evt.note, 0x00); // Note Off, Channel 1, Velocity 0
                lastTime = evt.time;
            });
            // End of Track Meta Event (0xFF 0x2F 0x00)
            trackData.push(0x00, 0xFF, 0x2F, 0x00);

            const trackHeader = [0x4D, 0x54, 0x72, 0x6B, ...numToBytes(trackData.length, 4)];
            const midiFile = new Uint8Array([...HEADER_CHUNK, ...trackHeader, ...trackData]);
            const blob = new Blob([midiFile], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'my_humming_melody.mid';
            a.click();
            URL.revokeObjectURL(url);
        });

    </script>
</body>
</html>
