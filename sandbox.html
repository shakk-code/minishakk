<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Physics Sandbox — Forced Dark Mode</title>
  <!-- Load Tailwind, then set config to class-based dark mode -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' };
  </script>
  <style>
    html, body, #root { height: 100%; }
    canvas { image-rendering: pixelated; }
    /* Palette items */
    .item{ display:flex; align-items:center; gap:.5rem; padding:.45rem .6rem; border:1px solid rgba(255,255,255,.18); border-radius:.5rem; background:rgba(255,255,255,.06); color:#e5e7eb; cursor:grab }
    .item:active{ cursor:grabbing }
    /* Stage wrapper */
    .stage{ position:relative; flex:1; min-height:0; }
    .canvas-wrap{ position:relative; width:fit-content; height:fit-content; margin:auto; border-radius:12px; overflow:hidden; }
    .canvas-wrap::before{ content:""; position:absolute; inset:0; border-radius:12px; box-shadow:0 2px 8px rgba(0,0,0,.2), 0 16px 48px rgba(0,0,0,.25); pointer-events:none; z-index:0 }
    canvas#world{ display:block; border-radius:12px; position:relative; z-index:1; }
    canvas.overlay{ position:absolute; top:0; left:0; z-index:2; pointer-events:none; border-radius:12px; }
    /* Drop layer only enabled while dragging from palette */
    #drop-layer{ position:absolute; inset:0; z-index:3; pointer-events:none; }
  </style>
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
</head>
<body class="h-full bg-[#0b0c0e] text-gray-100">
  <div id="root" class="h-full flex flex-col">
    <!-- Toolbar -->
    <div class="flex flex-wrap gap-3 items-center px-4 py-3 border-b border-white/10 bg-[#0f1115]">
      <div class="text-lg font-medium">2D Physics Sandbox</div>
      <div class="ml-auto flex flex-wrap items-center gap-2">
        <span class="text-xs opacity-70">BG</span>
        <input id="bg-color" type="color" value="#1a1a1a" class="w-8 h-8 border rounded border-white/20 bg-transparent" />
        <span class="text-xs opacity-70">W</span>
        <input id="num-w" type="number" value="1100" class="w-20 px-2 py-1 border rounded bg-transparent border-white/20" />
        <span class="text-xs opacity-70">H</span>
        <input id="num-h" type="number" value="700" class="w-20 px-2 py-1 border rounded bg-transparent border-white/20" />
        <span class="text-xs opacity-70">Gravity</span>
        <select id="sel-grav" class="border rounded px-2 py-1 text-xs bg-transparent border-white/20">
          <option value="0">Zero (0)</option>
          <option value="1.62">Moon (1.62)</option>
          <option value="3.71">Mars (3.71)</option>
          <option value="9.81" selected>Earth (9.81)</option>
          <option value="24.79">Jupiter (24.79)</option>
        </select>
        <input id="num-grav" type="number" step="0.01" min="-30" max="30" value="9.81" class="w-20 px-2 py-1 border rounded bg-transparent border-white/20" />
        <span class="text-xs">m/s²</span>
        <span class="text-xs opacity-70">Solid</span>
        <input id="clr-solid" type="color" value="#7c8cff" class="w-8 h-8 border rounded border-white/20 bg-transparent" />
        <span class="text-xs opacity-70">Next size</span>
        <input id="rng-size" type="range" min="0.4" max="3" step="0.05" value="1" />
        <button id="btn-pause" class="px-3 py-1 rounded bg-white/10 text-white text-sm border border-white/20">Pause</button>
        <button id="btn-clear" class="px-3 py-1 rounded bg-white/10 text-white text-sm border border-white/20">Clear</button>
      </div>
    </div>

    <div class="flex flex-1 min-h-0">
      <!-- Palette -->
      <div id="palette" class="w-64 border-r border-white/10 p-3 overflow-y-auto bg-[#0f1115]">
        <div class="mb-4">
          <div class="text-sm font-medium mb-2">Solids</div>
          <div class="grid grid-cols-2 gap-2">
            <div class="item" data-payload='{"category":"SOLID","type":"Rectangle","label":"Rectangle"}'>Rectangle</div>
            <div class="item" data-payload='{"category":"SOLID","type":"Circle","label":"Circle"}'>Circle</div>
            <div class="item" data-payload='{"category":"SOLID","type":"Triangle","label":"Triangle"}'>Triangle</div>
            <div class="item" data-payload='{"category":"SOLID","type":"Pentagon","label":"Pentagon"}'>Pentagon</div>
            <div class="item" data-payload='{"category":"SOLID","type":"Rope","label":"Rope"}'>Rope</div>
          </div>
        </div>
        <div class="mb-4">
          <div class="text-sm font-medium mb-2">Liquids (drag = pour)</div>
          <div class="grid grid-cols-2 gap-2">
            <div class="item" style="background:#5ec8ff33;outline:1px solid #000" data-payload='{"category":"LIQUID","type":"Water","label":"Water"}'>Water</div>
            <div class="item" style="background:#c9252b33;outline:1px solid #000" data-payload='{"category":"LIQUID","type":"Ketchup","label":"Ketchup"}'>Ketchup</div>
            <div class="item" style="background:#d3c8a033;outline:1px solid #000" data-payload='{"category":"LIQUID","type":"Starch","label":"Starch"}'>Starch</div>
          </div>
        </div>
        <div class="mb-2">
          <div class="text-sm font-medium mb-2">Gasses (drag = emit)</div>
          <div class="grid grid-cols-2 gap-2">
            <div class="item" style="background:#cfe9ff66;outline:1px solid #000" data-payload='{"category":"GAS","type":"Air","label":"Air"}'>Air</div>
            <div class="item" style="background:#b6e37a66;outline:1px solid #000" data-payload='{"category":"GAS","type":"Fart","label":"Fart"}'>Fart</div>
            <div class="item" style="background:#d0d0d066;outline:1px solid #000" data-payload='{"category":"GAS","type":"Smoke","label":"Smoke"}'>Smoke</div>
          </div>
        </div>
        <div class="text-xs opacity-70 mt-6 space-y-1">
          <div>Drag liquid/gas tiles over <b>the canvas</b> to pour/emit. Drop to burst once.</div>
          <div>Hold an object + press <b>Q</b> to suspend/release.</div>
          <div>“Next size” applies only to the next solid.</div>
          <div>Rigid bodies: black outline. Fluids/gas: translucent overlays.</div>
        </div>
      </div>

      <!-- Stage -->
      <div class="stage flex items-center justify-center">
        <div class="canvas-wrap" id="canvas-wrap">
          <canvas id="world"></canvas>
          <canvas id="overlay" class="overlay"></canvas>
          <div id="drop-layer"></div>
        </div>
        <div id="drag-preview" class="hidden pointer-events-none absolute top-2 left-1/2 -translate-x-1/2 text-sm bg-black text-white px-2 py-1 rounded">Drop to add</div>
      </div>
    </div>
  </div>

  <script>
  const { Engine, Render, Runner, World, Bodies, Mouse, MouseConstraint, Composite, Constraint, Events, Vertices, Body } = Matter;
  const CATEGORY = { SOLID:'SOLID', LIQUID:'LIQUID', GAS:'GAS' };
  const SOLID_TYPES = { RECT:'Rectangle', CIRCLE:'Circle', TRIANGLE:'Triangle', PENTAGON:'Pentagon', ROPE:'Rope' };
  const LIQUID_TYPES = { WATER:'Water', KETCHUP:'Ketchup', STARCH:'Starch' };
  const GAS_TYPES = { AIR:'Air', FART:'Fart', SMOKE:'Smoke' };
  const STROKE = '#000';
  function hexToRgb(hex){ const m=hex.replace('#',''); const n=parseInt(m.length===3?m.split('').map(c=>c+c).join(''):m,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 } }

  // --- Fluid grid (drippy liquids + rising gas) ---
  class FluidGrid{ constructor(nx,ny){ this.nx=nx; this.ny=ny; this.N=nx*ny; this.u=new Float32Array(this.N); this.v=new Float32Array(this.N); this.u0=new Float32Array(this.N); this.v0=new Float32Array(this.N); this.lw=new Float32Array(this.N); this.lk=new Float32Array(this.N); this.ls=new Float32Array(this.N); this.lw0=new Float32Array(this.N); this.lk0=new Float32Array(this.N); this.ls0=new Float32Array(this.N); this.g=new Float32Array(this.N); this.g0=new Float32Array(this.N); this.timeScale=1; this.diff=0.0006; this.visc=0.0008; this.decayL=0.9995; this.decayG=0.996; this.liqGravity=14.0; this.gasBuoyancy=12.0; this.obs=new Uint8Array(this.N); this.gNorm=1; }
    setGravityNormalized(g){ this.gNorm=g }
    idx(i,j){ return i+j*this.nx }
    clear(){ this.u.fill(0); this.v.fill(0); this.lw.fill(0); this.lk.fill(0); this.ls.fill(0); this.g.fill(0) }
    setObstaclesFromBodies(bodies,w,h){ this.obs.fill(0); const sx=this.nx/w, sy=this.ny/h; for(const b of bodies){ if(!b||b.isSensor) continue; const min=b.bounds.min, max=b.bounds.max; const i0=Math.max(0,Math.floor(min.x*sx)), i1=Math.min(this.nx-1,Math.ceil(max.x*sx)); const j0=Math.max(0,Math.floor(min.y*sy)), j1=Math.min(this.ny-1,Math.ceil(max.y*sy)); for(let j=j0;j<=j1;j++) for(let i=i0;i<=i1;i++) this.obs[this.idx(i,j)]=1; } }
    addLiquid(x,y,amt,type,w,h){ const i=Math.floor(this.nx*(x/w)), j=Math.floor(this.ny*(y/h)); if(i<1||i>=this.nx-1||j<1||j>=this.ny-1) return; const k=this.idx(i,j); if(type==='Water') this.lw[k]+=amt; else if(type==='Ketchup') this.lk[k]+=amt; else this.ls[k]+=amt; }
    addGas(x,y,amt,w,h){ const i=Math.floor(this.nx*(x/w)), j=Math.floor(this.ny*(y/h)); if(i<1||i>=this.nx-1||j<1||j>=this.ny-1) return; this.g[this.idx(i,j)] += amt; }
    step(dt){ dt*=this.timeScale; const nx=this.nx, ny=this.ny, N=(i,j)=>this.idx(i,j);
      for(let j=1;j<ny-1;j++) for(let i=1;i<nx-1;i++){ const k=N(i,j); const L=this.lw[k]+this.lk[k]+this.ls[k]; if(L>1e-5) this.v[k]+=this.liqGravity*this.gNorm*dt; if(this.g[k]>1e-5) this.v[k]-=this.gasBuoyancy*this.gNorm*dt; }
      this.diffuse(1,this.u0,this.u,this.visc,dt); this.diffuse(2,this.v0,this.v,this.visc,dt); this.project(this.u0,this.v0,this.u,this.v); this.advect(1,this.u,this.u0,this.u0,this.v0,dt); this.advect(2,this.v,this.v0,this.u0,this.v0,dt); this.project(this.u,this.v,this.u0,this.v0);
      this.diffuse(0,this.lw0,this.lw,this.diff*0.60,dt); this.advect(0,this.lw,this.lw0,this.u,this.v,dt);
      this.diffuse(0,this.lk0,this.lk,this.diff*0.35,dt); this.advect(0,this.lk,this.lk0,this.u,this.v,dt);
      this.diffuse(0,this.ls0,this.ls,this.diff*0.20,dt); this.advect(0,this.ls,this.ls0,this.u,this.v,dt);
      for(let k=0;k<this.N;k++){ this.lw[k]*=this.decayL; this.lk[k]*=this.decayL; this.ls[k]*=this.decayL; if(this.lw[k]<1e-6)this.lw[k]=0; if(this.lk[k]<1e-6)this.lk[k]=0; if(this.ls[k]<1e-6)this.ls[k]=0; }
      this.diffuse(0,this.g0,this.g,this.diff*0.95,dt); this.advect(0,this.g,this.g0,this.u,this.v,dt); for(let k=0;k<this.N;k++){ this.g[k]*=this.decayG; if(this.g[k]<1e-6)this.g[k]=0; }
      for(let j=1;j<ny-1;j++) for(let i=1;i<nx-1;i++){ const k=N(i,j); if(this.obs[k]){ this.u[k]=0; this.v[k]=0; }} }
    set_bnd(b,x){ const nx=this.nx,ny=this.ny; for(let i=1;i<nx-1;i++){ x[this.idx(i,0)]=b===2?-x[this.idx(i,1)]:x[this.idx(i,1)]; x[this.idx(i,ny-1)]=b===2?-x[this.idx(i,ny-2)]:x[this.idx(i,ny-2)] } for(let j=1;j<ny-1;j++){ x[this.idx(0,j)]=b===1?-x[this.idx(1,j)]:x[this.idx(1,j)]; x[this.idx(nx-1,j)]=b===1?-x[this.idx(nx-2,j)]:x[this.idx(nx-2,j)] } x[this.idx(0,0)]=.5*(x[this.idx(1,0)]+x[this.idx(0,1)]); x[this.idx(0,ny-1)]=.5*(x[this.idx(1,ny-1)]+x[this.idx(0,ny-2)]); x[this.idx(nx-1,0)]=.5*(x[this.idx(nx-2,0)]+x[this.idx(nx-1,1)]); x[this.idx(nx-1,ny-1)]=.5*(x[this.idx(nx-2,ny-1)]+x[this.idx(nx-1,ny-2)]) }
    lin_solve(b,x,x0,a,c){ for(let k=0;k<15;k++){ for(let j=1;j<this.ny-1;j++) for(let i=1;i<this.nx-1;i++){ x[this.idx(i,j)]=(x0[this.idx(i,j)]+a*(x[this.idx(i-1,j)]+x[this.idx(i+1,j)]+x[this.idx(i,j-1)]+x[this.idx(i,j+1)]))/c } this.set_bnd(b,x) } }
    diffuse(b,x,x0,diff,dt){ const a=dt*diff*(this.nx-2)*(this.ny-2); this.lin_solve(b,x,x0,a,1+4*a) }
    advect(b,d,d0,u,v,dt){ const nx=this.nx,ny=this.ny,dt0x=dt*(nx-2),dt0y=dt*(ny-2); for(let j=1;j<ny-1;j++){ for(let i=1;i<nx-1;i++){ let x=i-dt0x*u[this.idx(i,j)], y=j-dt0y*v[this.idx(i,j)]; if(x<.5)x=.5; if(x>nx-1.5)x=nx-1.5; if(y<.5)y=.5; if(y>ny-1.5)y=ny-1.5; const i0=Math.floor(x),i1=i0+1,j0=Math.floor(y),j1=j0+1,s1=x-i0,s0=1-s1,t1=y-j0,t0=1-t1; d[this.idx(i,j)]=s0*(t0*d0[this.idx(i0,j0)]+t1*d0[this.idx(i0,j1)])+s1*(t0*d0[this.idx(i1,j0)]+t1*d0[this.idx(i1,j1)]); } } this.set_bnd(b,d) }
    project(u,v,p,div){ const nx=this.nx,ny=this.ny; for(let j=1;j<ny-1;j++){ for(let i=1;i<nx-1;i++){ div[this.idx(i,j)]=-.5*(u[this.idx(i+1,j)]-u[this.idx(i-1,j)]+v[this.idx(i,j+1)]-v[this.idx(i,j-1)])/Math.max(nx,ny); p[this.idx(i,j)]=0 } } this.set_bnd(0,div); this.set_bnd(0,p); this.lin_solve(0,p,div,1,4); for(let j=1;j<ny-1;j++){ for(let i=1;i<nx-1;i++){ u[this.idx(i,j)]-=.5*(p[this.idx(i+1,j)]-p[this.idx(i-1,j)])*nx; v[this.idx(i,j)]-=.5*(p[this.idx(i,j+1)]-p[this.idx(i,j-1)])*ny } } this.set_bnd(1,u); this.set_bnd(2,v) }
  }

  // ======= App State =======
  let bgCanvas = '#1a1a1a'; // canvas background (independent of UI theme)
  let width=1100, height=700; let gMS2=9.81; let solidColor='#7c8cff'; let nextSize=1;
  let engine, render, runner, fluid, overlay, dropLayer, walls=[]; // globals

  const wrap = document.getElementById('canvas-wrap');
  const worldCanvas = document.getElementById('world');
  overlay = document.getElementById('overlay');
  dropLayer = document.getElementById('drop-layer');
  const palette = document.getElementById('palette');
  const dragPreview = document.getElementById('drag-preview');

  function mountWorld(){
    if(render){ try{ Render.stop(render); render.textures = {}; }catch(_){} }
    if(runner){ try{ Runner.stop(runner) }catch(_){} }
    if(engine){ try{ World.clear(engine.world,false); Engine.clear(engine) }catch(_){} }

    wrap.style.width = width + 'px'; wrap.style.height = height + 'px';
    worldCanvas.width = width; worldCanvas.height = height; overlay.width = width; overlay.height = height;

    engine = Engine.create(); engine.world.gravity.y = gMS2/9.81; engine.world.gravity.scale = 0.001;
    render = Render.create({ element: wrap, canvas: worldCanvas, engine, options:{ width, height, background: bgCanvas, wireframes:false, pixelRatio: window.devicePixelRatio || 1 } });

    const wallStyle = { render:{ fillStyle:bgCanvas, strokeStyle:'#000', lineWidth:2 } };
    walls = [ Bodies.rectangle(width/2, height+25, width, 50, {isStatic:true, ...wallStyle}), Bodies.rectangle(width/2, -25, width, 50, {isStatic:true, ...wallStyle}), Bodies.rectangle(-25, height/2, 50, height, {isStatic:true, ...wallStyle}), Bodies.rectangle(width+25, height/2, 50, height, {isStatic:true, ...wallStyle}) ];
    World.add(engine.world, walls);

    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine,{ mouse, constraint:{ stiffness:0.2, render:{ visible:false } } });
    World.add(engine.world, mouseConstraint); render.mouse = mouse;

    window.onkeydown = (e)=>{ if((e.key||'').toLowerCase()==='q'){ const b=mouseConstraint.body; if(b) Body.setStatic(b, !b.isStatic); } };

    const nx=Math.max(56, Math.floor(width/9)), ny=Math.max(42, Math.floor(height/9)); // slightly higher res
    fluid = new FluidGrid(nx, ny); fluid.setGravityNormalized(gMS2/9.81);
    const ctx = overlay.getContext('2d');

    Events.on(engine,'afterUpdate',()=>{
      engine.world.gravity.y = gMS2/9.81; fluid.setGravityNormalized(gMS2/9.81);
      const bodies = Composite.allBodies(engine.world).filter(b=>!b.isStatic && !b.isSensor);
      fluid.setObstaclesFromBodies(bodies,width,height);
      if(activeSource && render.mouse){ const m=render.mouse.position; const amt=3.0; if(activeSource.category==='LIQUID') fluid.addLiquid(m.x,m.y,amt,activeSource.type,width,height); if(activeSource.category==='GAS') fluid.addGas(m.x,m.y,amt*0.9,width,height); }
      fluid.step(1/60);

      // draw overlay
      ctx.clearRect(0,0,width,height);
      const sx=width/fluid.nx, sy=height/fluid.ny;
      const cW=hexToRgb('#5ec8ff'); const cK=hexToRgb('#c9252b'); const cS=hexToRgb('#d3c8a0');
      const cA=hexToRgb('#cfe9ff');

      for(let j=0;j<fluid.ny;j++){
        for(let i=0;i<fluid.nx;i++){
          const k=fluid.idx(i,j);
          const x0=(i*sx)|0, y0=(j*sy)|0, pw=Math.max(1,Math.ceil(sx)), ph=Math.max(1,Math.ceil(sy));
          const w=fluid.lw[k], kx=fluid.lk[k], st=fluid.ls[k], g=fluid.g[k];
          if(w>1e-3){ ctx.globalAlpha=Math.min(0.97, 0.18 + w*0.28); ctx.fillStyle=`rgba(${cW.r},${cW.g},${cW.b},1)`; ctx.fillRect(x0,y0,pw,ph) }
          if(kx>1e-3){ ctx.globalAlpha=Math.min(0.98, 0.22 + kx*0.30); ctx.fillStyle=`rgba(${cK.r},${cK.g},${cK.b},1)`; ctx.fillRect(x0,y0,pw,ph) }
          if(st>1e-3){ ctx.globalAlpha=Math.min(0.99, 0.26 + st*0.34); ctx.fillStyle=`rgba(${cS.r},${cS.g},${cS.b},1)`; ctx.fillRect(x0,y0,pw,ph) }
          if(g>1e-3){ ctx.globalAlpha=Math.min(0.46, 0.12 + g*0.24); ctx.fillStyle=`rgba(${cA.r},${cA.g},${cA.b},1)`; ctx.fillRect(x0,y0,pw,ph) }
        }
      }
      ctx.globalAlpha=1;
    });

    Render.run(render); runner = Runner.create(); Runner.run(runner, engine);
  }

  function updateBackground(color){ bgCanvas = color; if(render){ render.options.background = bgCanvas; } if(walls && walls.length){ walls.forEach(w=>{ w.render.fillStyle = bgCanvas; }); } }
  function baseStyle(fill){ return { render:{ fillStyle: fill, strokeStyle:'#000', lineWidth:2 } } }
  function addBody(b){ World.add(engine.world,b) }
  function addComposite(c){ World.add(engine.world,c) }
  function consumeSize(){ const s=nextSize; nextSize=1; document.getElementById('rng-size').value='1'; return s }

  // Spawners
  function spawnRectangle(x,y,color=solidColor){ const s=consumeSize(); const w=200*s,h=160*s; const r=Bodies.rectangle(x,y,w,h,{...baseStyle(color)}); addBody(r) }
  function spawnCircle(x,y,color=solidColor){ const s=consumeSize(); const R=50*s; const c=Bodies.circle(x,y,R,{...baseStyle(color)}); addBody(c) }
  function spawnTriangle(x,y,color=solidColor){ const s=consumeSize(); const size=140*s; const v=Vertices.fromPath(`0 0 ${size} 0 ${size/2} ${Math.round(Math.sqrt(3)*(size/2))}`); const t=Bodies.fromVertices(x,y,v,{...baseStyle(color)},true); addBody(t) }
  function spawnPentagon(x,y,color=solidColor){ const s=consumeSize(); const p=Bodies.polygon(x,y,5,70*s,{...baseStyle(color)}); addBody(p) }
  function spawnRope(x,y,segments=12,slack=8,color=solidColor){ const group=Body.nextGroup(true); const parts=[], cons=[], spacing=20; let prev=null; for(let i=0;i<segments;i++){ const ball=Bodies.circle(x+i*1,y+i*1,6,{ collisionFilter:{group}, ...baseStyle(color), friction:0.3, frictionAir:0.015, density:0.0008 }); parts.push(ball); if(prev){ const c=Constraint.create({ bodyA:prev, bodyB:ball, length:spacing-slack, stiffness:0.9, render:{visible:false} }); cons.push(c) } prev=ball } const comp=Composite.create({label:`Rope_${Date.now()}`}); Composite.add(comp,[...parts,...cons]); addComposite(comp) }

  // Emitters
  function emitLiquid(x,y,type){ if(!fluid) return; fluid.addLiquid(x,y,3.0,type,width,height) }
  function emitGas(x,y){ if(!fluid) return; fluid.addGas(x,y,2.5,width,height) }

  // DnD
  let activeSource=null;
  palette.querySelectorAll('.item').forEach(el=>{
    el.setAttribute('draggable','true');
    el.addEventListener('dragstart',(e)=>{ const p=JSON.parse(el.getAttribute('data-payload')); e.dataTransfer.effectAllowed='copy'; e.dataTransfer.setData('text/plain', JSON.stringify(p)); dragPreview.classList.remove('hidden'); dragPreview.textContent=`Drop to add: ${p.label}`; activeSource=(p.category!==CATEGORY.SOLID)?p:null; document.getElementById('drop-layer').style.pointerEvents='auto'; });
    el.addEventListener('dragend',()=>{ dragPreview.classList.add('hidden'); activeSource=null; document.getElementById('drop-layer').style.pointerEvents='none'; });
  });

  function getLocalXY(evt){ const rect = worldCanvas.getBoundingClientRect(); const scaleX = width / rect.width; const scaleY = height / rect.height; return { x: (evt.clientX-rect.left)*scaleX, y:(evt.clientY-rect.top)*scaleY } }

  document.getElementById('drop-layer').addEventListener('dragover',(e)=>{ e.preventDefault(); const data=e.dataTransfer.getData('text/plain'); if(!data) return; const p=JSON.parse(data); const {x,y}=getLocalXY(e); if(p.category===CATEGORY.LIQUID) emitLiquid(x,y,p.type); if(p.category===CATEGORY.GAS) emitGas(x,y); });
  document.getElementById('drop-layer').addEventListener('drop',(e)=>{ e.preventDefault(); dragPreview.classList.add('hidden'); const data=e.dataTransfer.getData('text/plain'); if(!data) return; const p=JSON.parse(data); const {x,y}=getLocalXY(e); if(p.category==='SOLID'){ switch(p.type){ case 'Rectangle': return spawnRectangle(x,y); case 'Circle': return spawnCircle(x,y); case 'Triangle': return spawnTriangle(x,y); case 'Pentagon': return spawnPentagon(x,y); case 'Rope': return spawnRope(x,y,12); } } else if(p.category==='LIQUID'){ emitLiquid(x,y,p.type) } else if(p.category==='GAS'){ emitGas(x,y) } document.getElementById('drop-layer').style.pointerEvents='none'; });

  // Controls
  document.getElementById('bg-color').addEventListener('input',(e)=>{ updateBackground(e.target.value) });
  document.getElementById('num-w').addEventListener('change',(e)=>{ width=Math.max(400, Number(e.target.value)||1100); mountWorld(); });
  document.getElementById('num-h').addEventListener('change',(e)=>{ height=Math.max(300, Number(e.target.value)||700); mountWorld(); });
  document.getElementById('sel-grav').addEventListener('change',(e)=>{ gMS2=Number(e.target.value)||0; document.getElementById('num-grav').value=gMS2; if(engine) engine.world.gravity.y=gMS2/9.81; if(fluid) fluid.setGravityNormalized(gMS2/9.81); });
  document.getElementById('num-grav').addEventListener('change',(e)=>{ gMS2=Number(e.target.value)||0; document.getElementById('sel-grav').value=String(gMS2); if(engine) engine.world.gravity.y=gMS2/9.81; if(fluid) fluid.setGravityNormalized(gMS2/9.81); });
  document.getElementById('clr-solid').addEventListener('input',(e)=>{ solidColor=e.target.value; });
  document.getElementById('rng-size').addEventListener('input',(e)=>{ nextSize=Number(e.target.value)||1; });
  document.getElementById('btn-clear').addEventListener('click',()=>{ const bodies=Composite.allBodies(engine.world).filter(b=>!b.isStatic); const cons=Composite.allConstraints(engine.world); bodies.forEach(b=>Composite.remove(engine.world,b)); cons.forEach(c=>Composite.remove(engine.world,c)); fluid && fluid.clear(); });
  document.getElementById('btn-pause').addEventListener('click',(e)=>{ const paused=engine.timing.timeScale===0; engine.timing.timeScale=paused?1:0; if(fluid) fluid.timeScale=paused?1:0; e.target.textContent=paused?'Pause':'Resume'; });

  // Boot
  mountWorld();
  </script>
</body>
</html>
