<!doctype html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Physics Sandbox</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' };
  </script>
  <style>
    html, body, #root { height: 100%; overflow: hidden; background-color: #0b0c0e; }
    
    /* UI Elements */
    .item { display:flex; align-items:center; gap:.5rem; padding:.45rem .6rem; border:1px solid rgba(255,255,255,.1); border-radius:.5rem; background:rgba(255,255,255,.03); color:#e5e7eb; cursor:pointer; user-select: none; transition: all 0.2s; font-size: 0.85rem; }
    .item:hover { background:rgba(255,255,255,.08); border-color: rgba(255,255,255,0.3); }
    .item.active-tool { border-color: #5ec8ff; background: rgba(94, 200, 255, 0.1); box-shadow: 0 0 15px rgba(94, 200, 255, 0.15); }
    
    /* Modal */
    .modal-backdrop { position: fixed; inset:0; background: rgba(0,0,0,0.7); backdrop-filter: blur(2px); z-index: 50; display: flex; align-items: center; justify-content: center; }
    .modal-content { background: #1f1f1f; border: 1px solid #333; border-radius: 8px; width: 400px; max-width: 90%; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
    .tab-btn { padding: 10px; flex: 1; text-align: center; cursor: pointer; border-bottom: 2px solid transparent; color: #888; }
    .tab-btn.active { border-bottom-color: #5ec8ff; color: white; font-weight: bold; }

    /* Canvas */
    .stage { position: relative; flex: 1; overflow: hidden; cursor: crosshair; }
    canvas { display: block; outline: none; }

    /* Controls */
    input[type="range"] { width: 100%; accent-color: #5ec8ff; }
    input[type="number"] { background: #111; border: 1px solid #333; color: white; padding: 4px; border-radius: 4px; width: 100%; }
    
    /* Stats */
    #stats { position: absolute; top: 10px; left: 10px; font-family: monospace; color: #00ff00; pointer-events: none; text-shadow: 1px 1px 0 #000; z-index: 10; }
  </style>
  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
</head>
<body class="text-gray-100 h-full flex flex-col" oncontextmenu="return false;">

  <div class="flex items-center px-4 py-2 border-b border-white/10 bg-[#0f1115] gap-4 h-14 shrink-0 z-20 relative">
    <div class="font-bold text-lg tracking-tight text-white/90">Physics<span class="text-blue-400">Box</span></div>
    
    <div class="h-6 w-px bg-white/10 mx-2"></div>
    
    <button id="btn-settings" class="item">‚öôÔ∏è Settings</button>
    <button id="btn-pause" class="item">‚è∏Ô∏è Pause</button>
    <button id="btn-clear" class="item text-red-300 hover:bg-red-900/20 border-red-900/30">üóëÔ∏è Clear World</button>

    <div class="ml-auto flex items-center gap-3 text-xs text-gray-400">
      <span>Scroll to Zoom</span>
      <span class="w-1 h-1 bg-gray-600 rounded-full"></span>
      <span>Middle Click to Pan</span>
      <span class="w-1 h-1 bg-gray-600 rounded-full"></span>
      <span>Right Click to Pour</span>
    </div>
  </div>

  <div class="flex flex-1 min-h-0 relative">
    <div class="w-64 border-r border-white/10 bg-[#0f1115] flex flex-col z-10 shrink-0">
      <div class="p-4 overflow-y-auto flex-1 space-y-6">
        
        <div>
          <div class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">Solids (Drag)</div>
          <div class="grid grid-cols-2 gap-2">
            <div class="item" draggable="true" data-type="Rectangle">‚¨ú Box</div>
            <div class="item" draggable="true" data-type="Circle">‚ö™ Circle</div>
            <div class="item" draggable="true" data-type="Triangle">üî∫ Triangle</div>
            <div class="item" draggable="true" data-type="Pentagon">‚¨† Pentagon</div>
            <div class="item" draggable="true" data-type="Rope">üîó Rope</div>
          </div>
        </div>

        <div>
          <div class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">Liquids (Equip)</div>
          <div class="space-y-2">
            <div class="item tool-item" onclick="app.equip('Water', 'LIQUID', this)" style="border-left: 3px solid #5ec8ff;">üíß Water</div>
            <div class="item tool-item" onclick="app.equip('Ketchup', 'LIQUID', this)" style="border-left: 3px solid #c9252b;">üçÖ Ketchup</div>
            <div class="item tool-item" onclick="app.equip('Starch', 'LIQUID', this)" style="border-left: 3px solid #d3c8a0;">ü•™ Starch</div>
          </div>
        </div>

        <div>
          <div class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">Gases (Equip)</div>
          <div class="space-y-2">
            <div class="item tool-item" onclick="app.equip('Air', 'GAS', this)" style="border-left: 3px solid #cfe9ff;">üí® Air</div>
            <div class="item tool-item" onclick="app.equip('Smoke', 'GAS', this)" style="border-left: 3px solid #888;">üå´Ô∏è Smoke</div>
          </div>
        </div>

      </div>
    </div>

    <div class="stage" id="stage">
      <div id="stats">FPS: 0</div>
      <canvas id="world"></canvas>
    </div>
  </div>

  <div id="settings-modal" class="modal-backdrop hidden">
    <div class="modal-content">
      <div class="flex border-b border-white/10 bg-black/20">
        <div class="tab-btn active" onclick="ui.switchTab('world')">World</div>
        <div class="tab-btn" onclick="ui.switchTab('fluid')">Fluid & Particles</div>
      </div>
      
      <div class="p-6 space-y-4" id="tab-world">
        <div>
          <label class="text-xs uppercase text-gray-500 font-bold">Canvas Width</label>
          <input type="number" id="inp-width" value="2000">
        </div>
        <div>
          <label class="text-xs uppercase text-gray-500 font-bold">Canvas Height</label>
          <input type="number" id="inp-height" value="1500">
        </div>
        <div>
          <label class="text-xs uppercase text-gray-500 font-bold">Gravity Scale</label>
          <div class="flex gap-2">
            <input type="range" min="0" max="3" step="0.1" id="inp-grav-slide" oninput="document.getElementById('inp-grav').value=this.value">
            <input type="number" id="inp-grav" value="1" style="width: 60px">
          </div>
        </div>
      </div>

      <div class="p-6 space-y-4 hidden" id="tab-fluid">
        <div>
          <label class="text-xs uppercase text-gray-500 font-bold">Particle Radius (Resolution)</label>
          <div class="text-xs text-gray-400 mb-1">Smaller = More liquid-like, more lag. Larger = Balls.</div>
          <div class="flex gap-2 items-center">
            <input type="range" min="2" max="15" step="1" id="inp-p-rad" value="4">
            <span id="val-p-rad" class="w-8 text-right">4px</span>
          </div>
        </div>
        <div>
          <label class="text-xs uppercase text-gray-500 font-bold">Max Particles</label>
          <input type="number" id="inp-max-p" value="2000">
        </div>
      </div>

      <div class="p-4 border-t border-white/10 flex justify-end gap-2 bg-black/20">
        <button class="px-4 py-2 rounded bg-white/10 hover:bg-white/20 text-sm" onclick="ui.closeSettings()">Cancel</button>
        <button class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 text-sm font-bold" onclick="ui.saveSettings()">Apply</button>
      </div>
    </div>
  </div>

  <script>
    const { Engine, World, Bodies, Mouse, MouseConstraint, Composite, Composites, Constraint, Events, Vertices, Body, Query, Vector } = Matter;

    // --- Application Logic ---
    const app = {
      width: 2000,
      height: 1500,
      engine: null,
      runner: null,
      canvas: null,
      ctx: null,
      
      // Viewport
      zoom: 1,
      pan: { x: 0, y: 0 },
      isPanning: false,
      lastMouse: { x: 0, y: 0 },

      // State
      paused: false,
      activeTool: null, 
      isRightClick: false,
      
      // Systems
      fluid: null,
      walls: [],

      init() {
        this.canvas = document.getElementById('world');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        
        // Setup Physics
        this.engine = Engine.create();
        this.engine.world.gravity.y = 1;
        
        // Setup Inputs
        this.setupInputs();
        
        // Initialize Fluid System
        this.fluid = new FluidSystem(this.width, this.height);
        
        // Initial resize
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Start Loop
        this.buildWalls();
        this.loop();
      },

      resize() {
        const stage = document.getElementById('stage');
        this.canvas.width = stage.clientWidth;
        this.canvas.height = stage.clientHeight;
        if(!this.frameCount || this.frameCount < 5) {
           this.pan.x = (this.canvas.width - this.width)/2;
           this.pan.y = (this.canvas.height - this.height)/2;
        }
      },

      buildWalls() {
        World.remove(this.engine.world, this.walls);
        const t = 200; // Thick padding, but invisible
        const w = this.width;
        const h = this.height;
        
        // Invisible Physics Bodies
        const wallOpt = { isStatic: true, render: { visible: false } };
        
        this.walls = [
          Bodies.rectangle(w/2, -t/2, w + 2*t, t, wallOpt), // Top
          Bodies.rectangle(w/2, h + t/2, w + 2*t, t, wallOpt), // Bottom
          Bodies.rectangle(-t/2, h/2, t, h + 2*t, wallOpt), // Left
          Bodies.rectangle(w + t/2, h/2, t, h + 2*t, wallOpt) // Right
        ];
        World.add(this.engine.world, this.walls);
      },

      equip(type, cat, el) {
        this.activeTool = { type, category: cat };
        document.querySelectorAll('.tool-item').forEach(e => e.classList.remove('active-tool'));
        if(el) el.classList.add('active-tool');
      },

      // --- Input Handling ---
      setupInputs() {
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomSpeed = 0.001;
          const newZoom = Math.max(0.1, Math.min(5, this.zoom - e.deltaY * zoomSpeed));
          
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          const worldX = (mouseX - this.pan.x) / this.zoom;
          const worldY = (mouseY - this.pan.y) / this.zoom;
          
          this.pan.x = mouseX - worldX * newZoom;
          this.pan.y = mouseY - worldY * newZoom;
          this.zoom = newZoom;
        }, { passive: false });

        this.canvas.addEventListener('mousedown', (e) => {
          if(e.button === 1 || (e.button === 0 && e.altKey)) {
            this.isPanning = true;
            this.lastMouse = { x: e.clientX, y: e.clientY };
            e.preventDefault();
          }
          if(e.button === 2) this.isRightClick = true;
        });

        window.addEventListener('mousemove', (e) => {
          if(this.isPanning) {
            const dx = e.clientX - this.lastMouse.x;
            const dy = e.clientY - this.lastMouse.y;
            this.pan.x += dx;
            this.pan.y += dy;
            this.lastMouse = { x: e.clientX, y: e.clientY };
          }
          this.handleFluidEmission(e);
        });

        window.addEventListener('mouseup', () => {
          this.isPanning = false;
          this.isRightClick = false;
        });
        
        const items = document.querySelectorAll('.item[draggable="true"]');
        let draggedType = null;
        
        items.forEach(el => {
          el.addEventListener('dragstart', (e) => {
             draggedType = el.getAttribute('data-type');
          });
        });
        
        this.canvas.addEventListener('dragover', e => e.preventDefault());
        this.canvas.addEventListener('drop', e => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mX = e.clientX - rect.left;
          const mY = e.clientY - rect.top;
          const worldPos = this.screenToWorld(mX, mY);
          
          if(draggedType) this.spawnSolid(draggedType, worldPos.x, worldPos.y);
        });

        window.addEventListener('keydown', e => {
          if(e.key.toLowerCase() === 'q') this.toggleFreezeHover();
        });
      },

      screenToWorld(sx, sy) {
        return { x: (sx - this.pan.x) / this.zoom, y: (sy - this.pan.y) / this.zoom };
      },

      handleFluidEmission(e) {
        if(this.activeTool && this.isRightClick) {
          const rect = this.canvas.getBoundingClientRect();
          const mX = e.clientX - rect.left;
          const mY = e.clientY - rect.top;
          const wPos = this.screenToWorld(mX, mY);
          
          this.fluid.add(wPos.x, wPos.y, this.activeTool.type);
          this.fluid.add(wPos.x + (Math.random()-0.5)*10, wPos.y + (Math.random()-0.5)*10, this.activeTool.type);
        }
      },

      toggleFreezeHover() { /* Placeholder */ },

      spawnSolid(type, x, y) {
        const opts = { render: { fillStyle: '#7c8cff', strokeStyle: '#000', lineWidth: 2 } };
        let body;
        
        switch(type) {
          case 'Rectangle': body = Bodies.rectangle(x, y, 100, 100, opts); break;
          case 'Circle': body = Bodies.circle(x, y, 50, opts); break;
          case 'Triangle': body = Bodies.polygon(x, y, 3, 60, opts); break;
          case 'Pentagon': body = Bodies.polygon(x, y, 5, 50, opts); break;
          case 'Rope': 
            // Un-anchored Chain
            const group = Body.nextGroup(true);
            const stack = Composites.stack(x, y, 15, 1, 5, 5, (xx, yy) => {
                return Bodies.circle(xx, yy, 6, { 
                    collisionFilter: { group: group }, 
                    frictionAir: 0.02,
                    render: { fillStyle: '#fff', strokeStyle:'#000', lineWidth:1 } 
                });
            });
            // Chain 'em
            Composites.chain(stack, 0.5, 0, -0.5, 0, { stiffness: 0.8, length: 2, render: { type: 'line', strokeStyle: '#fff', lineWidth: 2 } });
            // No anchor constraint added -> it falls freely
            World.add(this.engine.world, stack);
            return; 
        }
        if(body) World.add(this.engine.world, body);
      },

      // --- Main Loop ---
      loop() {
        if(!this.paused) {
          Engine.update(this.engine, 1000 / 60);
          this.fluid.update(this.engine, this.width, this.height);
        }
        this.render();
        this.updateStats();
        requestAnimationFrame(() => this.loop());
      },

      render() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        // 1. Reset & Clear
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);

        ctx.save();
        ctx.translate(this.pan.x, this.pan.y);
        ctx.scale(this.zoom, this.zoom);

        // 2. Draw World Border (Visual only)
        ctx.beginPath();
        ctx.rect(0, 0, this.width, this.height);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Shadow effect
        ctx.shadowColor = 'rgba(0,0,0,0.6)';
        ctx.shadowBlur = 30;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 10;
        ctx.fillStyle = 'rgba(20,20,20,0.5)'; // Inner subtle fill
        ctx.fill();
        ctx.shadowBlur = 0; // Turn off shadow for rest

        // 3. Draw Fluid (Background Layer)
        this.fluid.render(ctx);

        // 4. Draw Ropes (Middle Layer)
        const composites = Composite.allComposites(this.engine.world);
        const drawCons = (list) => {
            ctx.beginPath();
            ctx.strokeStyle = '#ddd'; // Rope Color
            ctx.lineWidth = 2;
            for(let c of list) {
                if(c.render.visible === false) continue;
                const pA = c.bodyA ? Vector.add(c.bodyA.position, c.pointA) : c.pointA;
                const pB = c.bodyB ? Vector.add(c.bodyB.position, c.pointB) : c.pointB;
                ctx.moveTo(pA.x, pA.y);
                ctx.lineTo(pB.x, pB.y);
            }
            ctx.stroke();
        };
        for(let comp of composites) {
            drawCons(Composite.allConstraints(comp));
        }
        // Loose constraints
        drawCons(Composite.allConstraints(this.engine.world));

        // 5. Draw Solids (Top Layer)
        const getAllBodies = (composite) => {
            let bodies = composite.bodies;
            for (let comp of composite.composites) {
                bodies = bodies.concat(getAllBodies(comp));
            }
            return bodies;
        };
        const bodies = getAllBodies(this.engine.world);

        for(let b of bodies) {
            if(b.render.visible === false) continue; // Skip invisible walls
            
            ctx.beginPath();
            const vertices = b.vertices;
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for(let j=1; j<vertices.length; j++) {
                ctx.lineTo(vertices[j].x, vertices[j].y);
            }
            ctx.lineTo(vertices[0].x, vertices[0].y);
            ctx.closePath();
            
            ctx.fillStyle = b.render.fillStyle || '#888';
            ctx.fill();
            
            ctx.strokeStyle = b.render.strokeStyle || '#000';
            ctx.lineWidth = b.render.lineWidth || 1;
            ctx.stroke();
        }

        ctx.restore();
      },

      updateStats() {
        if(!this.lastTime) this.lastTime = performance.now();
        const now = performance.now();
        if(now - this.lastTime >= 1000) {
             const fps = Math.round(1000 / ((now - this.lastTime) / (this.frameCount || 1)));
             document.getElementById('stats').innerText = `FPS: ${fps} | Particles: ${this.fluid.particles.length}`;
             this.lastTime = now;
             this.frameCount = 0;
        }
        this.frameCount = (this.frameCount || 0) + 1;
      }
    };

    // --- Fluid System ---
    class FluidSystem {
      constructor(w, h) {
        this.width = w;
        this.height = h;
        this.particles = [];
        this.limit = 2000;
        this.radius = 4;
        this.cellSize = 20;
        this.gravity = 1;
        
        this.props = {
          'Water': { c: '#5ec8ff', drag: 0.99, grav: 0.2 },
          'Ketchup': { c: '#c9252b', drag: 0.96, grav: 0.2 },
          'Starch': { c: '#d3c8a0', drag: 0.92, grav: 0.2 },
          'Air': { c: '#cfe9ff', drag: 0.98, grav: -0.05, gas: true },
          'Smoke': { c: '#888', drag: 0.96, grav: -0.02, gas: true }
        };
      }

      add(x, y, type) {
        if(this.particles.length >= this.limit) return;
        this.particles.push({
           x, y, 
           vx: (Math.random()-0.5), vy: (Math.random()-0.5),
           type, 
           conf: this.props[type],
           life: 1.0
        });
      }

      update(engine, w, h) {
        const getAllBodies = (composite) => {
            let bodies = composite.bodies;
            for (let comp of composite.composites) {
                bodies = bodies.concat(getAllBodies(comp));
            }
            return bodies;
        };
        const bodies = getAllBodies(engine.world).filter(b => !b.isSensor && b.render.visible !== false);

        const grid = new Map();
        const r = this.radius;
        const diam = r * 2;
        const rSq = diam * diam;

        // Spatial Hash
        for(let p of this.particles) {
           const k = `${Math.floor(p.x/this.cellSize)},${Math.floor(p.y/this.cellSize)}`;
           if(!grid.has(k)) grid.set(k, []);
           grid.get(k).push(p);
        }

        for(let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            p.vy += p.conf.grav * this.gravity;
            p.vx *= p.conf.drag;
            p.vy *= p.conf.drag;

            // Neighbors
            const cx = Math.floor(p.x/this.cellSize);
            const cy = Math.floor(p.y/this.cellSize);
            
            for(let xx = cx-1; xx<=cx+1; xx++) {
                for(let yy = cy-1; yy<=cy+1; yy++) {
                    const cell = grid.get(`${xx},${yy}`);
                    if(cell) {
                        for(let other of cell) {
                            if(other === p) continue;
                            const dx = p.x - other.x;
                            const dy = p.y - other.y;
                            const distSq = dx*dx + dy*dy;
                            if(distSq < rSq && distSq > 0.001) {
                                const dist = Math.sqrt(distSq);
                                const force = (diam - dist) * 0.15; 
                                const nx = dx/dist;
                                const ny = dy/dist;
                                p.vx += nx * force;
                                p.vy += ny * force;
                            }
                        }
                    }
                }
            }

            p.x += p.vx;
            p.y += p.vy;

            // Canvas Bounds
            if(p.x < r) { p.x = r; p.vx *= -0.5; }
            if(p.x > w - r) { p.x = w - r; p.vx *= -0.5; }
            if(p.y < r) { p.y = r; p.vy *= -0.5; }
            if(p.y > h - r) { p.y = h - r; p.vy *= -0.5; }

            // Solid Collision
            for(let b of bodies) {
                if(b.bounds.min.x > p.x + r || b.bounds.max.x < p.x - r || 
                   b.bounds.min.y > p.y + r || b.bounds.max.y < p.y - r) continue;

                if(Matter.Vertices.contains(b.vertices, {x: p.x, y: p.y})) {
                    let minDist = Infinity;
                    let normal = { x: 0, y: 0 };
                    const v = b.vertices;
                    for(let j=0; j<v.length; j++) {
                        const v1 = v[j];
                        const v2 = v[(j+1) % v.length];
                        const ex = v2.x - v1.x;
                        const ey = v2.y - v1.y;
                        const lenSq = ex*ex + ey*ey;
                        let t = ((p.x - v1.x) * ex + (p.y - v1.y) * ey) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                        const cx = v1.x + t * ex;
                        const cy = v1.y + t * ey;
                        const dx = p.x - cx;
                        const dy = p.y - cy;
                        const distSq = dx*dx + dy*dy;
                        if(distSq < minDist) {
                            minDist = distSq;
                            const dist = Math.sqrt(distSq);
                            normal = { x: dx/dist, y: dy/dist };
                        }
                    }
                    const push = Math.sqrt(minDist) + r; 
                    p.x += normal.x * push;
                    p.y += normal.y * push;
                    p.vx *= 0.5; p.vy *= 0.5;
                    p.vx += normal.x * 0.5; p.vy += normal.y * 0.5;
                }
            }

            if(p.conf.gas) {
                p.life -= 0.005;
                if(p.life <= 0) this.particles.splice(i, 1);
            }
        }
      }

      render(ctx) {
        for(let p of this.particles) {
           ctx.fillStyle = p.conf.c;
           ctx.globalAlpha = p.conf.gas ? p.life * 0.5 : 1;
           ctx.beginPath();
           ctx.arc(p.x, p.y, this.radius, 0, Math.PI*2);
           ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    }

    // --- UI ---
    const ui = {
      openSettings() { document.getElementById('settings-modal').classList.remove('hidden'); },
      closeSettings() { document.getElementById('settings-modal').classList.add('hidden'); },
      switchTab(tab) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('[id^="tab-"]').forEach(t => t.classList.add('hidden'));
        event.target.classList.add('active');
        document.getElementById('tab-'+tab).classList.remove('hidden');
      },
      saveSettings() {
        app.width = Number(document.getElementById('inp-width').value);
        app.height = Number(document.getElementById('inp-height').value);
        app.buildWalls();
        app.engine.world.gravity.y = Number(document.getElementById('inp-grav').value);
        app.fluid.gravity = app.engine.world.gravity.y;
        app.fluid.radius = Number(document.getElementById('inp-p-rad').value);
        app.fluid.limit = Number(document.getElementById('inp-max-p').value);
        this.closeSettings();
      }
    };

    document.getElementById('btn-settings').onclick = () => ui.openSettings();
    document.getElementById('btn-pause').onclick = (e) => {
       app.paused = !app.paused;
       e.target.innerText = app.paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
    };
    document.getElementById('btn-clear').onclick = () => {
       const bodies = Composite.allBodies(app.engine.world).filter(b => !b.isStatic);
       World.remove(app.engine.world, bodies);
       const composites = Composite.allComposites(app.engine.world);
       World.remove(app.engine.world, composites);
       app.fluid.particles = [];
    };
    document.getElementById('inp-p-rad').oninput = (e) => {
      document.getElementById('val-p-rad').innerText = e.target.value + "px";
    };

    // --- Start ---
    app.init();
    
    const mCon = MouseConstraint.create(app.engine, {
        mouse: Mouse.create(app.canvas),
        constraint: { stiffness: 0.2, render: { visible: false } }
    });
    World.add(app.engine.world, mCon);
    
    Events.on(app.engine, 'beforeUpdate', () => {
        const m = mCon.mouse;
        Mouse.setScale(m, { x: 1/app.zoom, y: 1/app.zoom });
        Mouse.setOffset(m, { x: -app.pan.x/app.zoom, y: -app.pan.y/app.zoom });
    });

  </script>
</body>
</html>
